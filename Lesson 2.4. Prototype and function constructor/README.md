<h1>Домашнее задание к лекции 2.4 «Прототип и конструктор функции»</h1>
<p>Перед началом работы скопируйте код к себе в редактор:</p>
<p>
  const items = [<br>
      {<br>
        title: 'Телепорт бытовой VZHIH-101',<br>
        available: 7,<br>
        holded: 0<br>
      },<br>
      {<br>
        title: 'Ховерборд Mattel 2016',<br>
        available: 4,<br>
        holded: 5<br>
      },<br>
      {<br>
        title: 'Меч световой FORCE (синий луч)',<br>
        available: 1,<br>
        holded: 1<br>
      }<br>
    ];<br>
</p>

<h2>Задача 1. Продажа со склада и из резерва «в долг».</h2>
<p>Перед началом работы добавьте этот код в редактор:</p>
<p>
  const itemPrototype = {<br>
  sell(field, amount = 1) {<br>
    if (this[field] < amount) {<br>
      throw `Недостаточно товара для продажи (${this[field]} из ${amount})`<br>
    }<br>
    this[field] -= amount;<br>
    return true;<br>
  },<br>
  sellHolded(amount = 1) {<br>
    return itemPrototype.sell.call(this, 'holded', amount);<br>
  },<br>
  sellAvailable(amount = 1) {<br>
    return itemPrototype.sell.call(this, 'available', amount);<br>
  }<br>
};<br>
</p>
<p>Нам нужно обновлять остатки товаров на складе при продаже товара. У нас уже есть функционал для этого в объекте itemPrototype. Но, как говорит наш ведущий разработчик, мы не можем вносить изменения в объекты из массива items, поэтому требуется найти другое решение, которое не затронет товары, и при этом задействует уже существующий функционал.</p>
<p>Функция sellItem должна принимать товар из массива items или аналогичный и обновлять его остатки и резерв, используя функции itemPrototype.sellAvailable, если продажа осуществляется из остатка или itemPrototype.sellHolded, если продажа осуществляется из резерва. Функция сама не должна никак изменять объект товара. Принимает следующие аргументы:</p>
<ul>
  <li>item — товар, объект</li>
  <li>amount — количество товара, которое требуется зарезервировать, целое число</li>
  <li>isHolded — нужно ли списывать из резерва, по умолчанию false, логический тип</li>
</ul>

<h2>Задача 2. Форматированный вывод списка.</h2>
<p>Перед началом работы добавьте код в редактор:</p>
<p>
  function formatFull() {<br>
  return `${this.title}:\n\tдоступно ${this.available} шт.\n\tв резерве ${this.holded} шт.`;<br>
}<br>
<br>
function formatLite() {<br>
  return `${this.title} (${this.available} + ${this.holded})`;<br>
}<br>
<br>
function show(format) {<br>
  console.log(format());<br>
}<br>
</p>
<p>В разных разделах системы нам нужно выводить список товаров в разном виде. Поэтому нужна функция, которая бы выводила каждый товар, используя функцию show, отформатировав товар заданной функцией, например formatFull или formatLite.</p>
<p>Реализовать функцию showItems, которая будет принимать список товаров, аналогичный массиву items, и выводить каждый элемент списка, используя функцию show и переданную функцию форматирования товара. Принимает следующие аргументы:</p>
<ul>
  <li>list — список товаров, массив</li>
  <li>formatter — функция форматирования, функция</li>
</ul>
<p>Функция не должна менять объекты в массиве list и сама что-либо выводить в консоль. Обратите внимание на то, что функция show принимает функцию, которая должна вернуть строку.</p>
    
<h2>Задача 3. Кнопка «Купить».</h2>
<p>Перед началом работы скопируйте код в редактор:</p>
<p>
  function createButton(title, onclick) {<br>
  return {<br>
    title,<br>
    onclick,<br>
    click() {<br>
      this.onclick.call(this);<br>
    }<br>
  };<br>
}
</p>
<p>Создайте функцию createBuyButtons, которая будет принимать список товаров, и для каждого товара из списка создаст кнопку с заголовком Купить, используя функцию createButton. При «клике» на кнопку для товара с названием Телепорт бытовой VZHIH-101 в консоль должно выводиться Телепорт бытовой VZHIH-101 добавлен в корзину. Функция принимает следующий аргумент: items — список товаров, аналогичный items, массив</p>
<p>Функция должна вернуть массив кнопок, созданных функцией createButton. Функция createButton принимает название кнопки и функцию, которая вызывается при «клике» на кнопку. Клик на кнопке симулируется вызовом метода click у созданной кнопки.</p>